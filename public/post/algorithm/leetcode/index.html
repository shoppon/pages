<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title> - Shoppon&#39;s site</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Shoppon" /><meta name="description" content="leetcode题解 动态规划 概念 动态规划算法一般用于求极值场景。 符合动态规划思想的几个条件： 具有最优子结构。 无后效性：状态一段确定，后面的演" /><meta name="keywords" content="Hugo, theme, even" />






<meta name="generator" content="Hugo 0.68.3 with theme even" />


<link rel="canonical" href="http://0.0.0.0:1313/post/algorithm/leetcode/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.c7bc1becf36bcf6a9ebd25d2947e43a2eb745ddb0c9a32b43126fd7fa460c351.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="" />
<meta property="og:description" content="leetcode题解 动态规划 概念 动态规划算法一般用于求极值场景。 符合动态规划思想的几个条件： 具有最优子结构。 无后效性：状态一段确定，后面的演" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://0.0.0.0:1313/post/algorithm/leetcode/" />

<meta itemprop="name" content="">
<meta itemprop="description" content="leetcode题解 动态规划 概念 动态规划算法一般用于求极值场景。 符合动态规划思想的几个条件： 具有最优子结构。 无后效性：状态一段确定，后面的演">

<meta itemprop="wordCount" content="2988">



<meta itemprop="keywords" content="" /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="leetcode题解 动态规划 概念 动态规划算法一般用于求极值场景。 符合动态规划思想的几个条件： 具有最优子结构。 无后效性：状态一段确定，后面的演"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Shoppon&#39;s Site</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">首页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">文档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Shoppon&#39;s Site</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">首页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">文档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title"></h1>

      <div class="post-meta">
        <span class="post-time"> 0001-01-01 </span>
        
          <span class="more-meta"> 约 2988 字 </span>
          <span class="more-meta"> 预计阅读 6 分钟 </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#leetcode题解">leetcode题解</a></li>
    <li><a href="#动态规划">动态规划</a>
      <ul>
        <li><a href="#概念">概念</a></li>
        <li><a href="#练习">练习</a>
          <ul>
            <li><a href="#42-接雨水httpsleetcode-cncomproblemstrapping-rain-water"><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></a></li>
            <li><a href="#887-鸡蛋掉落httpsleetcode-cncomproblemssuper-egg-drop"><a href="https://leetcode-cn.com/problems/super-egg-drop/">887. 鸡蛋掉落</a></a></li>
            <li><a href="#128-最长连续序列httpsleetcode-cncomproblemslongest-consecutive-sequence"><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></a></li>
            <li><a href="#62-不同路径httpsleetcode-cncomproblemsunique-paths"><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#字符串">字符串</a>
      <ul>
        <li><a href="#练习-1">练习</a>
          <ul>
            <li><a href="#140-单词拆分-iihttpsleetcode-cncomproblemsword-break-ii"><a href="https://leetcode-cn.com/problems/word-break-ii/">140. 单词拆分 II</a></a></li>
            <li><a href="#567-字符串的排列httpsleetcode-cncomproblemspermutation-in-string"><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></a></li>
            <li><a href="#1239-串联字符串的最大长度httpsleetcode-cncomproblemsmaximum-length-of-a-concatenated-string-with-unique-characters"><a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/">1239. 串联字符串的最大长度</a></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#数组">数组</a>
      <ul>
        <li><a href="#练习-2">练习</a>
          <ul>
            <li><a href="#4寻找两个有序数组的中位数httpsleetcode-cncomproblemsmedian-of-two-sorted-arrays"><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4.寻找两个有序数组的中位数</a></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#数据结构">数据结构</a>
      <ul>
        <li><a href="#栈">栈</a>
          <ul>
            <li><a href="#895-最大频率栈httpsleetcode-cncomproblemsmaximum-frequency-stack"><a href="https://leetcode-cn.com/problems/maximum-frequency-stack/">895. 最大频率栈</a></a></li>
            <li><a href="#503-下一个更大元素-iihttpsleetcode-cncomproblemsnext-greater-element-ii"><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></a></li>
            <li><a href="#315-计算右侧小于当前元素的个数httpsleetcode-cncomproblemscount-of-smaller-numbers-after-self"><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></a></li>
            <li><a href="#631-设计-excel-求和公式httpsleetcode-cncomproblemsdesign-excel-sum-formula"><a href="https://leetcode-cn.com/problems/design-excel-sum-formula/">631. 设计 Excel 求和公式</a></a></li>
          </ul>
        </li>
        <li><a href="#前缀和">前缀和</a>
          <ul>
            <li><a href="#1109-航班预订统计httpsleetcode-cncomproblemscorporate-flight-bookings"><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#树">树</a>
      <ul>
        <li><a href="#概念-1">概念</a>
          <ul>
            <li><a href="#树的遍历">树的遍历</a></li>
          </ul>
        </li>
        <li><a href="#练习-3">练习</a>
          <ul>
            <li><a href="#98-验证二叉搜索树httpsleetcode-cncomproblemsvalidate-binary-search-tree"><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#图">图</a>
      <ul>
        <li><a href="#概念-2">概念</a>
          <ul>
            <li><a href="#欧拉图">欧拉图</a></li>
            <li><a href="#搜索">搜索</a></li>
            <li><a href="#连通性">连通性</a></li>
            <li><a href="#最短路径">最短路径</a></li>
            <li><a href="#最小生成树">最小生成树</a></li>
            <li><a href="#图的表示">图的表示</a></li>
          </ul>
        </li>
        <li><a href="#练习-4">练习</a>
          <ul>
            <li><a href="#329-矩阵中的最长递增路径httpsleetcode-cncomproblemslongest-increasing-path-in-a-matrix"><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></a></li>
            <li><a href="#207-课程表httpsleetcode-cncomproblemscourse-schedule"><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></a></li>
            <li><a href="#753-破解保险箱httpsleetcode-cncomproblemscracking-the-safe"><a href="https://leetcode-cn.com/problems/cracking-the-safe/">753. 破解保险箱</a></a></li>
            <li><a href="#827-最大人工岛httpsleetcode-cncomproblemsmaking-a-large-island"><a href="https://leetcode-cn.com/problems/making-a-large-island/">827. 最大人工岛</a></a></li>
            <li><a href="#547-朋友圈httpsleetcode-cncomproblemsfriend-circles"><a href="https://leetcode-cn.com/problems/friend-circles/">547. 朋友圈</a></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#搜索-1">搜索</a>
      <ul>
        <li><a href="#回溯">回溯</a>
          <ul>
            <li><a href="#46-全排列httpsleetcode-cncomproblemspermutations"><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></a></li>
          </ul>
        </li>
        <li><a href="#其他">其他</a>
          <ul>
            <li><a href="#503-下一个更大元素-iihttpsleetcode-cncomproblemsnext-greater-element-ii-1"><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#排序">排序</a>
      <ul>
        <li><a href="#调度">调度</a>
          <ul>
            <li><a href="#621-任务调度器httpsleetcode-cncomproblemstask-scheduler"><a href="https://leetcode-cn.com/problems/task-scheduler/">621. 任务调度器</a></a></li>
            <li><a href="#253-会议室-iihttpsleetcode-cncomproblemsmeeting-rooms-ii"><a href="https://leetcode-cn.com/problems/meeting-rooms-ii/">253. 会议室 II</a></a></li>
            <li><a href="#315-计算右侧小于当前元素的个数httpsleetcode-cncomproblemscount-of-smaller-numbers-after-self-1"><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#数学">数学</a>
      <ul>
        <li><a href="#概念-3">概念</a>
          <ul>
            <li><a href="#位操作">位操作</a></li>
          </ul>
        </li>
        <li><a href="#练习-5">练习</a>
          <ul>
            <li><a href="#1224-最大相等频率httpsleetcode-cncomproblemsmaximum-equal-frequency"><a href="https://leetcode-cn.com/problems/maximum-equal-frequency/">1224. 最大相等频率</a></a></li>
          </ul>
        </li>
      </ul>
    </li>
    <li><a href="#待做列表">待做列表</a></li>
    <li><a href="#难题">难题</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h1 id="leetcode题解">leetcode题解</h1>
<h1 id="动态规划">动态规划</h1>
<h2 id="概念">概念</h2>
<p>动态规划算法一般用于求极值场景。</p>
<p>符合动态规划思想的几个条件：</p>
<ol>
<li>具有最优子结构。</li>
<li>无后效性：状态一段确定，后面的演变不受前面状态和决策的影响。</li>
<li>具有重叠子问题</li>
</ol>
<p>动态规划四个步骤：</p>
<ul>
<li>问题拆解，找到问题之间的具体联系</li>
<li>状态定义</li>
<li>递推方程推导</li>
<li>实现</li>
</ul>
<h2 id="练习">练习</h2>
<h3 id="42-接雨水httpsleetcode-cncomproblemstrapping-rain-water"><a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></h3>
<p>思路：对于所有的拐点，依次找出接水区间；接水区间可以描述为左右能找到的最大值。区间能接的水为两边的<strong>较小值</strong>减去区间点的值。</p>
<p>当前这个点能接的雨水量为从最左边到该点的最大值与从最右边到该点的最大值中较小值与其值的差。</p>
<h3 id="887-鸡蛋掉落httpsleetcode-cncomproblemssuper-egg-drop"><a href="https://leetcode-cn.com/problems/super-egg-drop/">887. 鸡蛋掉落</a></h3>
<p>鸡蛋足够的情况下，二分应该是最快的。</p>
<p>k=1, n=2时，ans=1</p>
<p>k=2, n=2时，ans=max((1,1), (2,1))+1=1</p>
<p>k=2, n=3时，ans=max((1,2),(2,2)+1=2</p>
<h5 id="总结">总结</h5>
<ol>
<li>能够拆分成子问题，并且能降低问题的规模</li>
<li>子问题的解不影响父问题的解，无后效性</li>
</ol>
<h3 id="128-最长连续序列httpsleetcode-cncomproblemslongest-consecutive-sequence"><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[100, 4, 200, 1, 3, 2]
</code></pre></td></tr></table>
</div>
</div><p>f(n)连续序列、长度、上下限</p>
<p>使用字典(hash)保存每个数字当前所在连续序列的<strong>长度</strong>。</p>
<p>遍历数组，对于每个元素，其最长序列的值为缓存中相邻最长续列的和加一，如果不存在则为0。同时该数字出现后有可能将其他序列连接起来了，因此需要更新左边序列的<strong>下限</strong>和右边序列的<strong>上限</strong>。</p>
<h3 id="62-不同路径httpsleetcode-cncomproblemsunique-paths"><a href="https://leetcode-cn.com/problems/unique-paths/">62. 不同路径</a></h3>
<p>记f(m,n)为到m,n点的步数</p>
<p>f(m,n)=f(m-1,n)+f(m, n-1)</p>
<p>如果用递归明显会栈溢出和超时，需要从底向上。</p>
<h1 id="字符串">字符串</h1>
<h2 id="练习-1">练习</h2>
<h3 id="140-单词拆分-iihttpsleetcode-cncomproblemsword-break-ii"><a href="https://leetcode-cn.com/problems/word-break-ii/">140. 单词拆分 II</a></h3>
<p>遍历单词，如果当前子串在字典中能找到，则从下一位置开始重新查找；如果找不到则继续添加子串，如果到最后还找不到则说明无解。</p>
<p>如何找出所有的解？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="n">s</span> <span class="o">=</span> <span class="s2">&#34;catsanddog&#34;</span>
<span class="n">wordDict</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&#34;cat&#34;</span><span class="p">,</span> <span class="s2">&#34;cats&#34;</span><span class="p">,</span> <span class="s2">&#34;and&#34;</span><span class="p">,</span> <span class="s2">&#34;sand&#34;</span><span class="p">,</span> <span class="s2">&#34;dog&#34;</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="567-字符串的排列httpsleetcode-cncomproblemspermutation-in-string"><a href="https://leetcode-cn.com/problems/permutation-in-string/">567. 字符串的排列</a></h3>
<p>如何判断&quot;cba&quot;是&quot;abc&quot;排列的一种？字符种类一样。。</p>
<p>思路：</p>
<ol>
<li>先统计子串中各字符出现的次数（配额）。</li>
<li>子串长度前一个要出队，如果<strong>使用过</strong>则次数加1。</li>
<li>遍历父串，当前还有配额时，配额减1，总次数减1</li>
<li>如果配额为0，需要用当前字符替换该字符最早出现的字符。可以用<strong>队列</strong>存储出现的顺序。</li>
<li>如果最后次数减为0，说明是子串。</li>
</ol>
<p>总结：情况太多了，太容易遗漏了！！！</p>
<p>复杂度较高的方法：使用数组统计每个字符出现的次数，比较次数是否一样</p>
<p>实际上效率更高。。好吧，想多了。。。</p>
<h3 id="1239-串联字符串的最大长度httpsleetcode-cncomproblemsmaximum-length-of-a-concatenated-string-with-unique-characters"><a href="https://leetcode-cn.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/">1239. 串联字符串的最大长度</a></h3>
<p>数组长度最大16，所以共2**16种情况，暴力遍历这些情况竟然过了。。。</p>
<p>另一种DFS暴力方法：</p>
<p>如果遍历完了则返回<strong>结果字符串</strong>的长度，否则<strong>判断结果字符串能否加上当前字符串</strong>，如果不能加则DFS下一个；如果能加则还要<strong>判断加与不加两种情况下</strong>的最大值，因为加了可能导致反而更小。</p>
<h1 id="数组">数组</h1>
<h2 id="练习-2">练习</h2>
<h3 id="4寻找两个有序数组的中位数httpsleetcode-cncomproblemsmedian-of-two-sorted-arrays"><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/">4.寻找两个有序数组的中位数</a></h3>
<p>要求算法的时间复杂度为 O(log(m + n))</p>
<p>找出前(m+n)/2最小的数</p>
<p>每次比较两个数组的前两个数，POP出较小的数，直到达到(m+n)/2个。</p>
<h1 id="数据结构">数据结构</h1>
<h2 id="栈">栈</h2>
<h3 id="895-最大频率栈httpsleetcode-cncomproblemsmaximum-frequency-stack"><a href="https://leetcode-cn.com/problems/maximum-frequency-stack/">895. 最大频率栈</a></h3>
<p>很明显要设计<code>push</code>和<code>pop</code>操作均为O1的数据结构。</p>
<p>使用频率字典记录每个字符的频率，使用元素字典记录频率为X的字母栈。同时更新当前最大频率。</p>
<h3 id="503-下一个更大元素-iihttpsleetcode-cncomproblemsnext-greater-element-ii"><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h3>
<p>对于每一个元素，遍历找到其下一个更大的元素。明显可能会超时。</p>
<p>**单调栈：**元素从栈顶到栈底依次递增或者递减。解决类似<em>最近</em>、<em>下一个</em>这种问题。</p>
<p>出栈时，对于<strong>出栈元素</strong>：</p>
<ol>
<li><strong>当前元素</strong>是<strong>右边</strong>第一个比其小的元素。</li>
<li><strong>栈顶元素</strong>是<strong>左边</strong>第一个比其小的元素。</li>
</ol>
<h3 id="315-计算右侧小于当前元素的个数httpsleetcode-cncomproblemscount-of-smaller-numbers-after-self"><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></h3>
<p>例如<code>[3, 10, 6, 7, 5, 9, 1]</code>，如果从右到左维护一个单调栈。</p>
<h3 id="631-设计-excel-求和公式httpsleetcode-cncomproblemsdesign-excel-sum-formula"><a href="https://leetcode-cn.com/problems/design-excel-sum-formula/">631. 设计 Excel 求和公式</a></h3>
<p>难点应该在于修改了值之后如何联动。。。并且公式嵌套时如何联动。。</p>
<h2 id="前缀和">前缀和</h2>
<h3 id="1109-航班预订统计httpsleetcode-cncomproblemscorporate-flight-bookings"><a href="https://leetcode-cn.com/problems/corporate-flight-bookings/">1109. 航班预订统计</a></h3>
<p>明显，使用暴力求和会超时。</p>
<p>一个航班从[i, j, k]的航班记录可以表示为res[i] = k, res[j+1] = -k，统计时res[i] = res[i] + res[i-1]，j+1由于记为负数，加起则为0。每个记录都可以如此处理。</p>
<p>技巧性太强了呀，还是很难想出来的。</p>
<h1 id="树">树</h1>
<h2 id="概念-1">概念</h2>
<p>树是一种特殊的图。</p>
<h3 id="树的遍历">树的遍历</h3>
<p><img src="/imgs/tree.jpg" alt="tree"></p>
<p>树的遍历有4种方法：后序、前序、中序、广度优先</p>
<h2 id="练习-3">练习</h2>
<h3 id="98-验证二叉搜索树httpsleetcode-cncomproblemsvalidate-binary-search-tree"><a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3>
<h1 id="图">图</h1>
<h2 id="概念-2">概念</h2>
<h3 id="欧拉图">欧拉图</h3>
<p>能通过所有的边且仅通过一次的图，该路径称为欧拉回路。</p>
<p>弗洛伊德算法：</p>
<h3 id="搜索">搜索</h3>
<p>**广度优先BFS：**使用队列，一般用于求最短路径、拓扑排序。。</p>
<p>**深度优先DFS：**递归或者使用栈。</p>
<p>**拓扑排序：**节点依赖顺序，所有有向边均从前面的元素指向后面的元素，<strong>有向无环图</strong>（DAG）排序</p>
<p>可用深搜实现，具体有三种方式：</p>
<ol>
<li>前序，递归调用之前将顶点加入队列</li>
<li>后序，递归调用之后将顶点加入队列</li>
<li>逆后序，递归调用之后将顶点压入栈</li>
</ol>
<h3 id="连通性">连通性</h3>
<p><strong>最大连通分量：</strong>
**连通分量计算：**并查集、深度优先搜索</p>
<h3 id="最短路径">最短路径</h3>
<p>迪杰斯特拉算法：</p>
<ol>
<li>找出最便宜的节点</li>
<li>更新该节点的邻居（松弛）</li>
<li>重复这个过程，直到所有节点遍历</li>
<li>计算最终路径</li>
</ol>
<h3 id="最小生成树">最小生成树</h3>
<p>图的生成树是包含所有顶点的<strong>无环连通子图</strong>。</p>
<p>Prim算法：</p>
<p>Kruskal算法：</p>
<h3 id="图的表示">图的表示</h3>
<p><img src="/imgs/dag.png" alt="dag" style="zoom:67%;" /></p>
<p>邻接矩阵：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="p">[</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
  <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
<span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><p>邻接表：使用字典保存每个起点所在边的终点集合。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span>
  <span class="s1">&#39;d&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>逆邻接表：使用字典保存每个终点所在边的起点集合。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-python" data-lang="python"><span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;d&#39;</span><span class="p">],</span>
  <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span>
  <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;d&#39;</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="练习-4">练习</h2>
<h3 id="329-矩阵中的最长递增路径httpsleetcode-cncomproblemslongest-increasing-path-in-a-matrix"><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></h3>
<p>将二维矩阵转换成有向图，目标比当前点的值大则有路径，否则不可达无路径。</p>
<p>暴力：从最小的节点进行深搜，获取最大值，直到所有的节点均被遍历</p>
<h4 id="深搜非递归实现步骤">深搜非递归实现步骤：</h4>
<ol>
<li>使用栈保存待访问的节点，使用集合保存已访问节点</li>
<li>从栈中POP出下一个要访问的节点</li>
<li>当栈非空时，依次访问当前节点的邻居，如果存在可访问的邻居节点，则将邻居加入到栈中</li>
</ol>
<h4 id="解决超时">解决超时</h4>
<ol>
<li>使用记忆数组保存遍历结果？？为什么下一次访问时可以用上一次结果？</li>
</ol>
<h3 id="207-课程表httpsleetcode-cncomproblemscourse-schedule"><a href="https://leetcode-cn.com/problems/course-schedule/">207. 课程表</a></h3>
<p>如果一个课程不被其他课程依赖则将其移除出去。如果一个顶点没有入度，则移除。
使用bfs进行拓扑排序</p>
<h3 id="753-破解保险箱httpsleetcode-cncomproblemscracking-the-safe"><a href="https://leetcode-cn.com/problems/cracking-the-safe/">753. 破解保险箱</a></h3>
<p>密码位数n，范围0~k-1，共有k^n种可能，需要将这k^n种可能放到一个长度最小的字符串中。</p>
<p>n=3,k=3</p>
<p>0001002001101112&mdash;</p>
<p>压缩后：00110</p>
<p>全排列去重。</p>
<h3 id="827-最大人工岛httpsleetcode-cncomproblemsmaking-a-large-island"><a href="https://leetcode-cn.com/problems/making-a-large-island/">827. 最大人工岛</a></h3>
<p><img src="/imgs/827.jpg" alt="827"></p>
<p>求面积方法：</p>
<ul>
<li>并查集的大小。</li>
<li>1与1连通，与0不连通，搜索节点个数。</li>
</ul>
<p>暴力：将每一个空地变成岛屿，计算之后的面积，找最大值。</p>
<p>优化：记录每块地方所在岛屿的面积，变化时加上其大小即可。</p>
<h3 id="547-朋友圈httpsleetcode-cncomproblemsfriend-circles"><a href="https://leetcode-cn.com/problems/friend-circles/">547. 朋友圈</a></h3>
<p>使用长度为n的数组保存每个人所在的朋友圈，如果后期与前面的为朋友则将其置为前个的编号。</p>
<p><img src="/imgs/547.jpg" alt="547"></p>
<p>关键点在于合并朋友圈，</p>
<p><strong>并查集：动态连通性。</strong></p>
<h1 id="搜索-1">搜索</h1>
<h2 id="回溯">回溯</h2>
<h3 id="46-全排列httpsleetcode-cncomproblemspermutations"><a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3>
<p>两个元素时，全排列为交换位置。</p>
<p>三个元素时，3*两个全排列</p>
<p>四个元素时，4*三个全排列</p>
<p>。。。</p>
<h2 id="其他">其他</h2>
<h3 id="503-下一个更大元素-iihttpsleetcode-cncomproblemsnext-greater-element-ii-1"><a href="https://leetcode-cn.com/problems/next-greater-element-ii/">503. 下一个更大元素 II</a></h3>
<p>最直观的方式：每一个遍历一遍，复杂度N2。</p>
<p>如何优化？扫一遍记录到当前位置的最大值。。</p>
<h1 id="排序">排序</h1>
<h2 id="调度">调度</h2>
<h3 id="621-任务调度器httpsleetcode-cncomproblemstask-scheduler"><a href="https://leetcode-cn.com/problems/task-scheduler/">621. 任务调度器</a></h3>
<p><img src="/imgs/621.jpg" alt="621"></p>
<p>记录任务冷却时间，每次取冷却时间最小的任务进行执行</p>
<p>先按间隔安排A任务，再安排B，再安排C。。。是否是最优解？不是，如果任务个数大于间隔。。</p>
<p>ABCDABCDABCDABCD</p>
<p>ABCABCABCABCDXXDXXD</p>
<p>思路：找出可以执行任务中个数量最多的。。。</p>
<p>桶思想：设置桶大小为n+1，桶个数为最多任务出现的次数。如果有相同次数，则个数加1。</p>
<h3 id="253-会议室-iihttpsleetcode-cncomproblemsmeeting-rooms-ii"><a href="https://leetcode-cn.com/problems/meeting-rooms-ii/">253. 会议室 II</a></h3>
<p>先按开始时间将会议室排序。。</p>
<p>**贪心算法：**每次选在上一个会议结束时间后开始最早的会议进行安排，安排不下了会议室加一。</p>
<h3 id="315-计算右侧小于当前元素的个数httpsleetcode-cncomproblemscount-of-smaller-numbers-after-self-1"><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/">315. 计算右侧小于当前元素的个数</a></h3>
<p>暴力查找，复杂度O(N2)，明显会超时。</p>
<p>线段数组：</p>
<p>归并排序：</p>
<p>树状数组：</p>
<h1 id="数学">数学</h1>
<h2 id="概念-3">概念</h2>
<h3 id="位操作">位操作</h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>符号</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>与</td>
<td>&amp;</td>
<td>0b11|0b00=0b00 3|0=0</td>
</tr>
<tr>
<td>或</td>
<td>|</td>
<td>0b10|0b01=0b11  2|1=3</td>
</tr>
<tr>
<td>非</td>
<td>~</td>
<td>~0b101=0b010</td>
</tr>
<tr>
<td>异或</td>
<td>^</td>
<td>0b10^0b01=0b11 2^1=3<br>0b11^0b00=0b00 3^0=3</td>
</tr>
<tr>
<td>左移</td>
<td>&laquo;</td>
<td>8&laquo;2=32</td>
</tr>
<tr>
<td>右移</td>
<td>&raquo;</td>
<td>8&raquo;2=2</td>
</tr>
</tbody>
</table>
<h2 id="练习-5">练习</h2>
<h3 id="1224-最大相等频率httpsleetcode-cncomproblemsmaximum-equal-frequency"><a href="https://leetcode-cn.com/problems/maximum-equal-frequency/">1224. 最大相等频率</a></h3>
<p>基础算是个数学逻辑题，需要分析清楚可以变成相等的几种情况。在没有用例的情况下把所有情况考虑全其实还是挺难的。</p>
<h1 id="待做列表">待做列表</h1>
<ul>
<li><a href="https://leetcode-cn.com/problems/word-search-ii/">212. 单词搜索 II</a></li>
<li><a href="https://leetcode-cn.com/problems/android-unlock-patterns/">351. 安卓系统手势解锁</a></li>
<li>1011</li>
<li>241</li>
<li>499</li>
<li>174</li>
<li>84</li>
<li>319</li>
<li>631</li>
</ul>
<h1 id="难题">难题</h1>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">Shoppon</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        0001-01-01
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      
      <nav class="post-nav">
        
        <a class="next" href="/post/arch/design/">
            <span class="next-text nav-default"></span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="comments-gitment"></div>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.min.css" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.min.js" crossorigin="anonymous"></script>
    <script type="text/javascript">
      var gitment = new Gitment({
        id: '0001-01-01 00:00:00 \x2b0000 UTC',
        title: '',
        link: decodeURI(location.href),
        desc: 'leetcode题解 动态规划 概念 动态规划算法一般用于求极值场景。 符合动态规划思想的几个条件： 具有最优子结构。 无后效性：状态一段确定，后面的演',
        owner: 'shoppon',
        repo: '',
        oauth: {
          client_id: '',
          client_secret: ''
        }
      });
      gitment.render('comments-gitment');
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/imsun/gitment">comments powered by gitment.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:shopppon@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="http://localhost:1313" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
      <a href="http://localhost:1313" class="iconfont icon-twitter" title="twitter"></a>
      <a href="http://localhost:1313" class="iconfont icon-facebook" title="facebook"></a>
      <a href="http://localhost:1313" class="iconfont icon-google" title="google"></a>
      <a href="http://localhost:1313" class="iconfont icon-github" title="github"></a>
      <a href="http://localhost:1313" class="iconfont icon-zhihu" title="zhihu"></a>
  <a href="http://0.0.0.0:1313/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2017 - 
    2020<span class="heart"><i class="iconfont icon-heart"></i></span><span>Shoppon</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c12618f9a600c40bd024996677e951e64d3487006775aeb22e200c990006c5c7.js"></script>








</body>
</html>
