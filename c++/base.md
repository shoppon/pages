# C/C++基础

## 数据结构

2. 字符串如何比较？

### 类型转换

| 源     | 目标      | 函数            |
| ------ | --------- | --------------- |
| 字符串 | ```int``` | ```std::stoi``` |
|        |           |                 |
|        |           |                 |

### List & Vector

Vector:

- 内存连续
- 预分配内存
- 每个元素仅需要其自身大小的空间（针额外指针空间）
- 当新添加元素时可自动重新分配内存
- 在尾部插入常数时间，其他位置O(n)时间。
- 在尾部删除常数时间，其他位置O(n)时间。
- 可以随机访问元素。
- 迭代过程中添加和删除元素是非法的。
- 可以获取底层数组。

List：

- 内存不连续
- 无预分配内存，单个元素所需内存大于其自身空间（前后指针)。
- 添加元素时不会自动重新分配内存。
- 无论在任何位置添加和删除的代价更小。
- 组合和分割列表代价更小。
- 无法随机访问元素，获取指定元素的代价更大。
- 迭代过程中可以添加和删除元素。
- 如果需要一个元素数组，必须创建一个然后添加元素。

## 左值和右值

**左值：**可以寻址的变量或表达式，既可以出现在等号左边也可以出现在等号右边。

**右值：**右值只能被const类型的reference所指向，非const引用是非法的。

## 智能指针

#### 智能指针引用计数。。。转值

智能指针的引用是否导致计数变化？

#### 智能指针的的引用计数如何变化？从queue中移除是否导致变化？

#### 智能指针在引用计数变为0后内存是否立即回收？

## 继承

#### 合理使用public、protected、private

体现面向对象设计的**封装性**，不对外暴露的尽量定义成```private```属性。同样，在修改函数的可见属性时，一定要三思，是否违反了设计者的初衷。将```pipe.cpp```的```UpdateTransmitter```属性从```private```修改为```public```即是反例，调用者不应该关系队列是如何更新的。

## 性能

对象拷贝的代价有多大？

在栈上分配然后返回和在堆上分配然后返回智能指针的区别？

## 宏

### 为什么宏都用`do while(0)`语法？

避免受到大括号、分号的影响，引起悬挂else等问题，具体见[这里](https://stackoverflow.com/questions/154136/why-use-apparently-meaningless-do-while-and-if-else-statements-in-macros)

## 调试

### 查看

查看依赖```ldd oma```

查看符号```readelf -d oma```

### 生成core文件

1. ```ulimit -c unlimited```
2. ```echo "/tmp/core-%e-%p-%t" > /proc/sys/kernel/core_pattern```
3. 重启进程，core文件路径在```/tmp/core-xxx```。
4. 执行```gdb /path/to/bin /path/to/core```进行调试。

## 工具

### pclint屏蔽

| 命令格式            | 说明                       | 举例                            |
| ------------------- | -------------------------- | ------------------------------- |
| -e#                 | 隐藏某类错误               | /*lint -e725 */                 |
| -e(#)               | 隐藏下一表达式中的某类错误 | /*lint –e(534) */               |
| !e#                 | 隐藏本行中的错误           | /*lint !e534 */                 |
| -esym(#, Symbol)    | 隐藏有关某符号的错误       | /*lint –esym(534, printf)*/     |
| -elib(#)            | 隐藏头文件中的某类错误     | /*lint –elib(129) */            |
| -efunc(#, \<func\>) | 隐藏某个函数中的特定错误   | /*lint –efunc(534, mchRelAll)*/ |
